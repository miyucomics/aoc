I was at first really fearful of today's puzzle, but after some laying in bed for around twelve minutes, I suddenly awoke with the vision.

The key is to maximize the highest place value you have first. Scan across the buffer ( the list of digits per line ) for the largest digit possible that still leaves space at the end of the buffer for the remaining digits that must be filled. For example in 811111111111119, the largest digit possible is 9 but that is at the end and leaves no room for the second digit we need to fill. Thus, we can only search in the space 81111111111111, where the largest digit is clearly 8. After that, 9 is the largest ( and only ) digit remaining.

For a better example, consider trying to pick three digits from 234234234234278 to maximize the score. 8 is the greatest but it is too far to the back. We need to leave room for two other digits, so our buffer can only be 2342342342342. We pick the first 4 since it is the highest and leaves the most buffer for the remaining two digits. Now we shrink the buffer so it is 234234234278 ( we removed until the first 4 that we picked ), and we repeat the process. We pick 7 here, shrink the buffer, and 8 is forced.

The reason this works is that it doesn't matter what digit we assign to the ones, the bigger the tens is, the better the number is objectively. A number can have 9 in the ones and 2 in the ten, and it would lose to 31. Therefore, we greedily maximize the highest place value we can legally fill while still leaving rooms for the remaining digits, even if all of them are forced digits.

For the eleganter solution, I just used a stack to easily promote up high numbers until we had no more possible removals.
